diff --git a/arr.patch b/arr.patch
deleted file mode 100644
index 3c6f06def..000000000
--- a/arr.patch
+++ /dev/null
@@ -1,390 +0,0 @@
-diff --git a/include/cantera/kinetics/T_Arrhenius.h b/include/cantera/kinetics/T_Arrhenius.h
-deleted file mode 100644
-index 8b809c23e..000000000
---- a/include/cantera/kinetics/T_Arrhenius.h
-+++ /dev/null
-@@ -1,218 +0,0 @@
--/**
-- * @file T_Arrhenius.h
-- * Header for reaction rates that involve temperature dependent Arrhenius-type kinetics.
-- */
--
--// This file is part of Cantera. See License.txt in the top-level directory or
--// at https://cantera.org/license.txt for license and copyright information.
--
--#ifndef CT_TARRHENIUS_H
--#define CT_TARRHENIUS_H
--
--#include "cantera/base/ct_defs.h"
--#include "cantera/base/Units.h"
--#include "cantera/kinetics/ReactionData.h"
--#include "ReactionRate.h"
--#include "MultiRate.h"
--
--namespace Cantera
--{
--
--class AnyValue;
--class AnyMap;
--
--//! Data container holding shared data specific to ArrheniusRate
--/**
-- * The data container `ArrheniusData` holds precalculated data common to
-- * all `ArrheniusRate` objects.
-- */
--struct TArrheniusData : public ReactionData
--{
--    bool update(const ThermoPhase& phase, const Kinetics& kin) override;
--    using ReactionData::update;
--};
--
--
--//! Base class for Arrhenius-type Parameterizations
--/*!
-- * This base class provides a minimally functional interface that allows for parameter
-- * access from derived classes as well as classes that use Arrhenius-type expressions
-- * internally, for example FalloffRate and PlogRate.
-- * @ingroup arrheniusGroup
-- */
--class TArrheniusBase : public ReactionRate
--{
--public:
--    //! Default constructor.
--    TArrheniusBase() {}
--
--    //! Constructor.
--    /*!
--     *  @param A  Pre-exponential factor. The unit system is (kmol, m, s); actual units
--     *      depend on the reaction order and the dimensionality (surface or bulk).
--     *  @param b  Temperature exponent (non-dimensional)
--     *  @param T0 Reference temperature (K)
--     *  @param Ea  Activation energy in energy units [J/kmol]
--     */
--    TArrheniusBase(double A, double b, double T0, double Ea);
--
--    //! Constructor based on AnyValue content
--    TArrheniusBase(const AnyValue& rate, const UnitSystem& units,  const UnitStack& rate_units);
--
--    explicit TArrheniusBase(const AnyMap& node, const UnitStack& rate_units={});
--
--    //! Perform object setup based on AnyValue node information
--    /*!
--     *  Used to set parameters from a child of the reaction node, which may have
--     *  different names for different rate parameterizations, such as falloff rates.
--     *
--     *  @param rate  Child of the reaction node containing Arrhenius rate parameters.
--     *      For example, the `rate-coefficient` node for a standard Arrhenius reaction.
--     *  @param units  Unit system
--     *  @param rate_units  Unit definitions specific to rate information
--     */
--    void setRateParameters(const AnyValue& rate,
--                           const UnitSystem& units,
--                           const UnitStack& rate_units);
--
--    //! Get Arrhenius parameters used to populate the `rate-coefficient` or
--    //! equivalent field
--    void getRateParameters(AnyMap& node) const;
--
--    void setParameters(const AnyMap& node, const UnitStack& rate_units) override;
--
--    void getParameters(AnyMap& node) const override;
--
--    //! Check rate expression
--    void check(const string& equation) override;
--
--    void validate(const string& equation, const Kinetics& kin) override;
--
--    //! Return the pre-exponential factor *A* (in m, kmol, s to powers depending
--    //! on the reaction order)
--    /*!
--     * Class specializations may provide alternate definitions that describe
--     * an effective pre-exponential factor that depends on the thermodynamic state.
--     */
--    virtual double preExponentialFactor() const {
--        return m_A;
--    }
--
--    //! Return the temperature exponent *b*
--    /*!
--     * Class specializations may provide alternate definitions that describe
--     * an effective temperature exponent that depends on the thermodynamic state.
--     */
--    virtual double temperatureExponent() const {
--        return m_b;
--    }
--    
--    virtual double refTemperature() const {
--        return m_T0;
--    }
--
--    //! Return the activation energy *Ea* [J/kmol]
--    //! The value corresponds to the constant specified by input parameters;
--    /*!
--     * Class specializations may provide alternate definitions that describe
--     * an effective activation energy that depends on the thermodynamic state.
--     */
--    virtual double activationEnergy() const {
--        return m_Ea_R * GasConstant;
--    }
--
--    //! Return reaction order associated with the reaction rate
--    double order() const {
--        return m_order;
--    }
--
--    //! Set units of the reaction rate expression
--    void setRateUnits(const UnitStack& rate_units) override {
--        ReactionRate::setRateUnits(rate_units);
--        if (rate_units.size() > 1) {
--            m_order = 1 - rate_units.product().dimension("quantity");
--        } else {
--            m_order = NAN;
--        }
--    }
--
--    //! Get flag indicating whether negative A values are permitted
--    bool allowNegativePreExponentialFactor() const {
--        return m_negativeA_ok;
--    }
--
--    //! Set flag indicating whether negative A values are permitted
--    void setAllowNegativePreExponentialFactor(bool value) {
--        m_negativeA_ok = value;
--    }
--
--protected:
--    bool m_negativeA_ok = false; //!< Permissible negative A values
--    double m_A = NAN; //!< Pre-exponential factor
--    double m_b = NAN; //!< Temperature exponent
--    double m_T0 = 1.0; //!< Reference temperature
--    double m_Ea_R = 0.; //!< Activation energy (in temperature units)
--    double m_E4_R = 0.; //!< Optional 4th energy parameter (in temperature units)
--    double m_logA = NAN; //!< Logarithm of pre-exponential factor
--    double m_order = NAN; //!< Reaction order
--    string m_A_str = "A"; //!< The string for the pre-exponential factor
--    string m_b_str = "b"; //!< The string for temperature exponent
--    string m_Ea_str = "Ea"; //!< The string for activation energy
--    string m_T0_str = "T0"; //!< The string for reference temperature
--    string m_E4_str = ""; //!< The string for an optional 4th parameter
--};
--
--//! Arrhenius reaction rate type depends only on temperature
--/*!
-- * A reaction rate coefficient of the following form.
-- *
-- *   @f[
-- *        k_f =  A T^b \exp (-Ea/RT)
-- *   @f]
-- *
-- * @ingroup arrheniusGroup
-- */
--class TArrheniusRate : public TArrheniusBase
--{
--public:
--    using TArrheniusBase::TArrheniusBase; // inherit constructors
--
--    unique_ptr<MultiRateBase> newMultiRate() const override {
--        return make_unique<MultiRate<TArrheniusRate, TArrheniusData>>();
--    }
--
--    const string type() const override {
--        return "T-Arrhenius";
--    }
--
--    //! Evaluate reaction rate
--    double evalRate(double logT, double recipT) const {
--        return m_A * std::exp((m_b * (logT - std::log(m_T0))) - (m_Ea_R * recipT));
--    }
--
--    //! Evaluate natural logarithm of the rate constant.
--    double evalLog(double logT, double recipT) const {
--        return m_logA + (m_b * (logT - std::log(m_T0))) - (m_Ea_R * recipT);
--    }
--
--    //! Evaluate reaction rate
--    /*!
--     *  @param shared_data  data shared by all reactions of a given type
--     */
--    double evalFromStruct(const TArrheniusData& shared_data) const {
--        return m_A * std::exp((m_b * (shared_data.logT - std::log(m_T0))) - (m_Ea_R * shared_data.recipT));
--    }
--
--    //! Evaluate derivative of reaction rate with respect to temperature
--    //! divided by reaction rate
--    /*!
--     *  @param shared_data  data shared by all reactions of a given type
--     */
--    double ddTScaledFromStruct(const TArrheniusData& shared_data) const {
--        return (m_Ea_R * shared_data.recipT + m_b) * shared_data.recipT;
--    }
--};
--
--}
--
--#endif
-diff --git a/src/kinetics/T_Arrhenius.cpp b/src/kinetics/T_Arrhenius.cpp
-deleted file mode 100644
-index 73e06b635..000000000
---- a/src/kinetics/T_Arrhenius.cpp
-+++ /dev/null
-@@ -1,160 +0,0 @@
--//! @file T_Arrhenius.cpp
--
--// This file is part of Cantera. See License.txt in the top-level directory or
--// at https://cantera.org/license.txt for license and copyright information.
--
--#include "cantera/kinetics/T_Arrhenius.h"
--#include "cantera/thermo/ThermoPhase.h"
--
--namespace Cantera
--{
--
--TArrheniusBase::TArrheniusBase(double A, double b, double T0, double Ea)
--    : m_A(A)
--    , m_b(b)
--    , m_T0(T0)
--    , m_Ea_R(Ea / GasConstant)
--{
--    if (m_A > 0.0) {
--        m_logA = std::log(m_A);
--    }
--    m_valid = true;
--}
--
--TArrheniusBase::TArrheniusBase(const AnyValue& rate, const UnitSystem& units,
--                             const UnitStack& rate_units)
--{
--    setRateUnits(rate_units);
--    setRateParameters(rate, units, rate_units);
--}
--
--TArrheniusBase::TArrheniusBase(const AnyMap& node, const UnitStack& rate_units)
--{
--    setParameters(node, rate_units);
--}
--
--void TArrheniusBase::setRateParameters(
--    const AnyValue& rate, const UnitSystem& units, const UnitStack& rate_units)
--{
--    m_Ea_R = 0.; // assume zero if not provided
--    m_E4_R = 0.; // assume zero if not provided
--    if (rate.empty()) {
--        m_A = NAN;
--        m_b = NAN;
--        m_T0 = 1.0;
--        m_logA = NAN;
--        setRateUnits(Units(0.));
--        return;
--    }
--
--    if (rate.is<AnyMap>()) {
--
--        auto& rate_map = rate.as<AnyMap>();
--        m_A = units.convertRateCoeff(rate_map[m_A_str], conversionUnits());
--        m_b = rate_map[m_b_str].asDouble();
--        m_T0 = rate_map[m_T0_str].asDouble();
--        if (rate_map.hasKey(m_Ea_str)) {
--            m_Ea_R = units.convertActivationEnergy(rate_map[m_Ea_str], "K");
--        }
--        if (rate_map.hasKey(m_E4_str)) {
--            m_E4_R = units.convertActivationEnergy(rate_map[m_E4_str], "K");
--        }
--    } else {
--        auto& rate_vec = rate.asVector<AnyValue>(2, 4);
--        m_A = units.convertRateCoeff(rate_vec[0], conversionUnits());
--        m_b = rate_vec[1].asDouble();
--        if (rate_vec.size() > 2) {
--            m_Ea_R = units.convertActivationEnergy(rate_vec[2], "K");
--        }
--        if (rate_vec.size() > 3) {
--            m_E4_R = units.convertActivationEnergy(rate_vec[3], "K");
--        }
--    }
--    if (m_A > 0.0) {
--        m_logA = std::log(m_A);
--    }
--    m_valid = true;
--}
--
--void TArrheniusBase::getRateParameters(AnyMap& node) const
--{
--    if (!valid()) {
--        // Return empty/unmodified AnyMap
--        return;
--    }
--
--    if (conversionUnits().factor() != 0.0) {
--        node[m_A_str].setQuantity(m_A, conversionUnits());
--    } else {
--        node[m_A_str] = m_A;
--        // This can't be converted to a different unit system because the dimensions of
--        // the rate constant were not set. Can occur if the reaction was created outside
--        // the context of a Kinetics object and never added to a Kinetics object.
--        node["__unconvertible__"] = true;
--    }
--    node[m_T0_str] = m_T0;
--    node[m_b_str] = m_b;
--    node[m_Ea_str].setQuantity(m_Ea_R, "K", true);
--    if (m_E4_str != "") {
--        node[m_E4_str].setQuantity(m_E4_R, "K", true);
--    }
--    node.setFlowStyle();
--}
--
--void TArrheniusBase::setParameters(const AnyMap& node, const UnitStack& rate_units)
--{
--    ReactionRate::setParameters(node, rate_units);
--    m_negativeA_ok = node.getBool("negative-A", false);
--    if (!node.hasKey("rate-constant")) {
--        setRateParameters(AnyValue(), node.units(), rate_units);
--        return;
--    }
--    setRateParameters(node["rate-constant"], node.units(), rate_units);
--}
--
--void TArrheniusBase::getParameters(AnyMap& node) const {
--    if (m_negativeA_ok) {
--        node["negative-A"] = true;
--    }
--    AnyMap rateNode;
--    getRateParameters(rateNode);
--    if (!rateNode.empty()) {
--        // RateType object is configured
--        node["rate-constant"] = std::move(rateNode);
--    }
--}
--
--void TArrheniusBase::check(const string& equation)
--{
--    if (!m_negativeA_ok && m_A < 0) {
--        if (equation == "") {
--            throw CanteraError("ArrheniusBase::check",
--                "Detected negative pre-exponential factor (A={}).\n"
--                "Enable 'allowNegativePreExponentialFactor' to suppress "
--                "this message.", m_A);
--        }
--        throw InputFileError("ArrheniusBase::check", m_input,
--            "Undeclared negative pre-exponential factor found in reaction '{}'",
--            equation);
--    }
--}
--
--void TArrheniusBase::validate(const string& equation, const Kinetics& kin)
--{
--    if (!valid()) {
--        throw InputFileError("ArrheniusBase::validate", m_input,
--            "Rate object for reaction '{}' is not configured.", equation);
--    }
--}
--
--bool TArrheniusData::update(const ThermoPhase& phase, const Kinetics& kin)
--{
--    double T = phase.temperature();
--    if (T == temperature) {
--        return false;
--    }
--    update(T);
--    return true;
--}
--
--}
diff --git a/include/cantera/kinetics/Photolysis.h b/include/cantera/kinetics/Photolysis.h
index 7373e03f7..e009c0365 100644
--- a/include/cantera/kinetics/Photolysis.h
+++ b/include/cantera/kinetics/Photolysis.h
@@ -152,7 +152,7 @@ class PhotolysisRate : public PhotolysisBase {
 };
 
 /**
- * @brief Read the cross-section data from VULCAN format files
+ * @breif Read the cross-section data from VULCAN format files
  *
  * @param branches Composition of the photodissociation products (no
  * photoabsorption branch). 
diff --git a/include/cantera/kinetics/T_Arrhenius.h b/include/cantera/kinetics/T_Arrhenius.h
deleted file mode 100644
index 8b809c23e..000000000
--- a/include/cantera/kinetics/T_Arrhenius.h
+++ /dev/null
@@ -1,218 +0,0 @@
-/**
- * @file T_Arrhenius.h
- * Header for reaction rates that involve temperature dependent Arrhenius-type kinetics.
- */
-
-// This file is part of Cantera. See License.txt in the top-level directory or
-// at https://cantera.org/license.txt for license and copyright information.
-
-#ifndef CT_TARRHENIUS_H
-#define CT_TARRHENIUS_H
-
-#include "cantera/base/ct_defs.h"
-#include "cantera/base/Units.h"
-#include "cantera/kinetics/ReactionData.h"
-#include "ReactionRate.h"
-#include "MultiRate.h"
-
-namespace Cantera
-{
-
-class AnyValue;
-class AnyMap;
-
-//! Data container holding shared data specific to ArrheniusRate
-/**
- * The data container `ArrheniusData` holds precalculated data common to
- * all `ArrheniusRate` objects.
- */
-struct TArrheniusData : public ReactionData
-{
-    bool update(const ThermoPhase& phase, const Kinetics& kin) override;
-    using ReactionData::update;
-};
-
-
-//! Base class for Arrhenius-type Parameterizations
-/*!
- * This base class provides a minimally functional interface that allows for parameter
- * access from derived classes as well as classes that use Arrhenius-type expressions
- * internally, for example FalloffRate and PlogRate.
- * @ingroup arrheniusGroup
- */
-class TArrheniusBase : public ReactionRate
-{
-public:
-    //! Default constructor.
-    TArrheniusBase() {}
-
-    //! Constructor.
-    /*!
-     *  @param A  Pre-exponential factor. The unit system is (kmol, m, s); actual units
-     *      depend on the reaction order and the dimensionality (surface or bulk).
-     *  @param b  Temperature exponent (non-dimensional)
-     *  @param T0 Reference temperature (K)
-     *  @param Ea  Activation energy in energy units [J/kmol]
-     */
-    TArrheniusBase(double A, double b, double T0, double Ea);
-
-    //! Constructor based on AnyValue content
-    TArrheniusBase(const AnyValue& rate, const UnitSystem& units,  const UnitStack& rate_units);
-
-    explicit TArrheniusBase(const AnyMap& node, const UnitStack& rate_units={});
-
-    //! Perform object setup based on AnyValue node information
-    /*!
-     *  Used to set parameters from a child of the reaction node, which may have
-     *  different names for different rate parameterizations, such as falloff rates.
-     *
-     *  @param rate  Child of the reaction node containing Arrhenius rate parameters.
-     *      For example, the `rate-coefficient` node for a standard Arrhenius reaction.
-     *  @param units  Unit system
-     *  @param rate_units  Unit definitions specific to rate information
-     */
-    void setRateParameters(const AnyValue& rate,
-                           const UnitSystem& units,
-                           const UnitStack& rate_units);
-
-    //! Get Arrhenius parameters used to populate the `rate-coefficient` or
-    //! equivalent field
-    void getRateParameters(AnyMap& node) const;
-
-    void setParameters(const AnyMap& node, const UnitStack& rate_units) override;
-
-    void getParameters(AnyMap& node) const override;
-
-    //! Check rate expression
-    void check(const string& equation) override;
-
-    void validate(const string& equation, const Kinetics& kin) override;
-
-    //! Return the pre-exponential factor *A* (in m, kmol, s to powers depending
-    //! on the reaction order)
-    /*!
-     * Class specializations may provide alternate definitions that describe
-     * an effective pre-exponential factor that depends on the thermodynamic state.
-     */
-    virtual double preExponentialFactor() const {
-        return m_A;
-    }
-
-    //! Return the temperature exponent *b*
-    /*!
-     * Class specializations may provide alternate definitions that describe
-     * an effective temperature exponent that depends on the thermodynamic state.
-     */
-    virtual double temperatureExponent() const {
-        return m_b;
-    }
-    
-    virtual double refTemperature() const {
-        return m_T0;
-    }
-
-    //! Return the activation energy *Ea* [J/kmol]
-    //! The value corresponds to the constant specified by input parameters;
-    /*!
-     * Class specializations may provide alternate definitions that describe
-     * an effective activation energy that depends on the thermodynamic state.
-     */
-    virtual double activationEnergy() const {
-        return m_Ea_R * GasConstant;
-    }
-
-    //! Return reaction order associated with the reaction rate
-    double order() const {
-        return m_order;
-    }
-
-    //! Set units of the reaction rate expression
-    void setRateUnits(const UnitStack& rate_units) override {
-        ReactionRate::setRateUnits(rate_units);
-        if (rate_units.size() > 1) {
-            m_order = 1 - rate_units.product().dimension("quantity");
-        } else {
-            m_order = NAN;
-        }
-    }
-
-    //! Get flag indicating whether negative A values are permitted
-    bool allowNegativePreExponentialFactor() const {
-        return m_negativeA_ok;
-    }
-
-    //! Set flag indicating whether negative A values are permitted
-    void setAllowNegativePreExponentialFactor(bool value) {
-        m_negativeA_ok = value;
-    }
-
-protected:
-    bool m_negativeA_ok = false; //!< Permissible negative A values
-    double m_A = NAN; //!< Pre-exponential factor
-    double m_b = NAN; //!< Temperature exponent
-    double m_T0 = 1.0; //!< Reference temperature
-    double m_Ea_R = 0.; //!< Activation energy (in temperature units)
-    double m_E4_R = 0.; //!< Optional 4th energy parameter (in temperature units)
-    double m_logA = NAN; //!< Logarithm of pre-exponential factor
-    double m_order = NAN; //!< Reaction order
-    string m_A_str = "A"; //!< The string for the pre-exponential factor
-    string m_b_str = "b"; //!< The string for temperature exponent
-    string m_Ea_str = "Ea"; //!< The string for activation energy
-    string m_T0_str = "T0"; //!< The string for reference temperature
-    string m_E4_str = ""; //!< The string for an optional 4th parameter
-};
-
-//! Arrhenius reaction rate type depends only on temperature
-/*!
- * A reaction rate coefficient of the following form.
- *
- *   @f[
- *        k_f =  A T^b \exp (-Ea/RT)
- *   @f]
- *
- * @ingroup arrheniusGroup
- */
-class TArrheniusRate : public TArrheniusBase
-{
-public:
-    using TArrheniusBase::TArrheniusBase; // inherit constructors
-
-    unique_ptr<MultiRateBase> newMultiRate() const override {
-        return make_unique<MultiRate<TArrheniusRate, TArrheniusData>>();
-    }
-
-    const string type() const override {
-        return "T-Arrhenius";
-    }
-
-    //! Evaluate reaction rate
-    double evalRate(double logT, double recipT) const {
-        return m_A * std::exp((m_b * (logT - std::log(m_T0))) - (m_Ea_R * recipT));
-    }
-
-    //! Evaluate natural logarithm of the rate constant.
-    double evalLog(double logT, double recipT) const {
-        return m_logA + (m_b * (logT - std::log(m_T0))) - (m_Ea_R * recipT);
-    }
-
-    //! Evaluate reaction rate
-    /*!
-     *  @param shared_data  data shared by all reactions of a given type
-     */
-    double evalFromStruct(const TArrheniusData& shared_data) const {
-        return m_A * std::exp((m_b * (shared_data.logT - std::log(m_T0))) - (m_Ea_R * shared_data.recipT));
-    }
-
-    //! Evaluate derivative of reaction rate with respect to temperature
-    //! divided by reaction rate
-    /*!
-     *  @param shared_data  data shared by all reactions of a given type
-     */
-    double ddTScaledFromStruct(const TArrheniusData& shared_data) const {
-        return (m_Ea_R * shared_data.recipT + m_b) * shared_data.recipT;
-    }
-};
-
-}
-
-#endif
diff --git a/src/kinetics/Photolysis.cpp b/src/kinetics/Photolysis.cpp
index 646f7b450..971ebb396 100644
--- a/src/kinetics/Photolysis.cpp
+++ b/src/kinetics/Photolysis.cpp
@@ -382,9 +382,6 @@ double PhotolysisRate::evalFromStruct(PhotolysisData const& data) {
  
 
     //N-space interpolation to determine photolysis cross section
-    // debug
-    //std::cout << "coord = " << coord[0] << " " << coord[1] << std::endl;
-
     interpn(cross1, coord, m_crossSection.data(), m_temp_wave_grid.data(),
         len, 2, m_branch.size());
 
@@ -400,15 +397,6 @@ double PhotolysisRate::evalFromStruct(PhotolysisData const& data) {
         m_net_products[name] = 0.;
     }
 
-    /* debug
-    std::cout << m_crossSection[0] << std::endl;
-    std::cout << m_crossSection[1] << std::endl;
-    std::cout << m_crossSection[2] << std::endl;
-    std::cout << "grid = " << std::endl;
-    for (int n = 0; n < m_temp_wave_grid.size(); n++) {
-      std::cout << m_temp_wave_grid[n] << std::endl;
-    }*/
-
     for (size_t i = 0; i < data.wavelength.size() - 1; ++i) {
       // debug
       //std::cout << "wavelength = " << data.wavelength[i] << " " << data.wavelength[i+1] << std::endl;
diff --git a/src/kinetics/T_Arrhenius.cpp b/src/kinetics/T_Arrhenius.cpp
deleted file mode 100644
index 73e06b635..000000000
--- a/src/kinetics/T_Arrhenius.cpp
+++ /dev/null
@@ -1,160 +0,0 @@
-//! @file T_Arrhenius.cpp
-
-// This file is part of Cantera. See License.txt in the top-level directory or
-// at https://cantera.org/license.txt for license and copyright information.
-
-#include "cantera/kinetics/T_Arrhenius.h"
-#include "cantera/thermo/ThermoPhase.h"
-
-namespace Cantera
-{
-
-TArrheniusBase::TArrheniusBase(double A, double b, double T0, double Ea)
-    : m_A(A)
-    , m_b(b)
-    , m_T0(T0)
-    , m_Ea_R(Ea / GasConstant)
-{
-    if (m_A > 0.0) {
-        m_logA = std::log(m_A);
-    }
-    m_valid = true;
-}
-
-TArrheniusBase::TArrheniusBase(const AnyValue& rate, const UnitSystem& units,
-                             const UnitStack& rate_units)
-{
-    setRateUnits(rate_units);
-    setRateParameters(rate, units, rate_units);
-}
-
-TArrheniusBase::TArrheniusBase(const AnyMap& node, const UnitStack& rate_units)
-{
-    setParameters(node, rate_units);
-}
-
-void TArrheniusBase::setRateParameters(
-    const AnyValue& rate, const UnitSystem& units, const UnitStack& rate_units)
-{
-    m_Ea_R = 0.; // assume zero if not provided
-    m_E4_R = 0.; // assume zero if not provided
-    if (rate.empty()) {
-        m_A = NAN;
-        m_b = NAN;
-        m_T0 = 1.0;
-        m_logA = NAN;
-        setRateUnits(Units(0.));
-        return;
-    }
-
-    if (rate.is<AnyMap>()) {
-
-        auto& rate_map = rate.as<AnyMap>();
-        m_A = units.convertRateCoeff(rate_map[m_A_str], conversionUnits());
-        m_b = rate_map[m_b_str].asDouble();
-        m_T0 = rate_map[m_T0_str].asDouble();
-        if (rate_map.hasKey(m_Ea_str)) {
-            m_Ea_R = units.convertActivationEnergy(rate_map[m_Ea_str], "K");
-        }
-        if (rate_map.hasKey(m_E4_str)) {
-            m_E4_R = units.convertActivationEnergy(rate_map[m_E4_str], "K");
-        }
-    } else {
-        auto& rate_vec = rate.asVector<AnyValue>(2, 4);
-        m_A = units.convertRateCoeff(rate_vec[0], conversionUnits());
-        m_b = rate_vec[1].asDouble();
-        if (rate_vec.size() > 2) {
-            m_Ea_R = units.convertActivationEnergy(rate_vec[2], "K");
-        }
-        if (rate_vec.size() > 3) {
-            m_E4_R = units.convertActivationEnergy(rate_vec[3], "K");
-        }
-    }
-    if (m_A > 0.0) {
-        m_logA = std::log(m_A);
-    }
-    m_valid = true;
-}
-
-void TArrheniusBase::getRateParameters(AnyMap& node) const
-{
-    if (!valid()) {
-        // Return empty/unmodified AnyMap
-        return;
-    }
-
-    if (conversionUnits().factor() != 0.0) {
-        node[m_A_str].setQuantity(m_A, conversionUnits());
-    } else {
-        node[m_A_str] = m_A;
-        // This can't be converted to a different unit system because the dimensions of
-        // the rate constant were not set. Can occur if the reaction was created outside
-        // the context of a Kinetics object and never added to a Kinetics object.
-        node["__unconvertible__"] = true;
-    }
-    node[m_T0_str] = m_T0;
-    node[m_b_str] = m_b;
-    node[m_Ea_str].setQuantity(m_Ea_R, "K", true);
-    if (m_E4_str != "") {
-        node[m_E4_str].setQuantity(m_E4_R, "K", true);
-    }
-    node.setFlowStyle();
-}
-
-void TArrheniusBase::setParameters(const AnyMap& node, const UnitStack& rate_units)
-{
-    ReactionRate::setParameters(node, rate_units);
-    m_negativeA_ok = node.getBool("negative-A", false);
-    if (!node.hasKey("rate-constant")) {
-        setRateParameters(AnyValue(), node.units(), rate_units);
-        return;
-    }
-    setRateParameters(node["rate-constant"], node.units(), rate_units);
-}
-
-void TArrheniusBase::getParameters(AnyMap& node) const {
-    if (m_negativeA_ok) {
-        node["negative-A"] = true;
-    }
-    AnyMap rateNode;
-    getRateParameters(rateNode);
-    if (!rateNode.empty()) {
-        // RateType object is configured
-        node["rate-constant"] = std::move(rateNode);
-    }
-}
-
-void TArrheniusBase::check(const string& equation)
-{
-    if (!m_negativeA_ok && m_A < 0) {
-        if (equation == "") {
-            throw CanteraError("ArrheniusBase::check",
-                "Detected negative pre-exponential factor (A={}).\n"
-                "Enable 'allowNegativePreExponentialFactor' to suppress "
-                "this message.", m_A);
-        }
-        throw InputFileError("ArrheniusBase::check", m_input,
-            "Undeclared negative pre-exponential factor found in reaction '{}'",
-            equation);
-    }
-}
-
-void TArrheniusBase::validate(const string& equation, const Kinetics& kin)
-{
-    if (!valid()) {
-        throw InputFileError("ArrheniusBase::validate", m_input,
-            "Rate object for reaction '{}' is not configured.", equation);
-    }
-}
-
-bool TArrheniusData::update(const ThermoPhase& phase, const Kinetics& kin)
-{
-    double T = phase.temperature();
-    if (T == temperature) {
-        return false;
-    }
-    update(T);
-    return true;
-}
-
-}
diff --git a/src/kinetics/load_xsection_vulcan.cpp b/src/kinetics/load_xsection_vulcan.cpp
index 89f72ef9d..e998c972c 100644
--- a/src/kinetics/load_xsection_vulcan.cpp
+++ b/src/kinetics/load_xsection_vulcan.cpp
@@ -8,6 +8,8 @@
 namespace Cantera
 {
 
+//! \return a pair of vectors containing the wavelength (m) 
+//! and cross section data (m^2 / m)
 pair<vector<double>, vector<double>> 
 load_xsection_vulcan(vector<string> const& files, vector<Composition> const& branches)
 {
@@ -53,14 +55,16 @@ load_xsection_vulcan(vector<string> const& files, vector<Composition> const& bra
     // TODO(AB): check this and we ignore pion
     // cm^2 -> m^2
     xsection.push_back(std::max(pabs - pdis, 0.) * 1.e-4);
-    // populate photodissociation cross sections for all branches
-    for (int i = 1; i < nbranch; ++i) {
-      xsection.push_back(pdis * 1.e-4);
-    }
+    xdiss.push_back(pdis * 1.e-4);
   }
 
   fclose(file1);
 
+  // populate photodissociation cross sections for all branches
+  for (int i = 1; i < nbranch; ++i) {
+    xsection.insert(xsection.end(), xdiss.begin(), xdiss.end());
+  }
+
   // read branch ratios
   FILE* file2 = fopen(files[1].c_str(), "r");
 
@@ -102,7 +106,7 @@ load_xsection_vulcan(vector<string> const& files, vector<Composition> const& bra
     interpn(br.data(), &wavelength[i], bratio.data(), bwave.data(), &len, 1, nbranch - 1);
 
     for (int j = 1; j < nbranch; ++j) {
-      xsection[i * nbranch + j] *= br[j - 1];
+      xsection[j * wavelength.size() + i] *= br[j - 1];
     }
   }
 
